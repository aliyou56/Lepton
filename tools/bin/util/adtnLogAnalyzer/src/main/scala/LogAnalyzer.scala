
import java.nio.file.{Files, Path, Paths}
import java.time.{LocalDateTime, Instant, ZoneId}
import java.time.temporal.ChronoUnit
import java.time.format.DateTimeFormatter
import scala.io.Source
import scala.util.{Try, Success, Failure}
import scala.collection.mutable.{Map, ArrayBuffer, ListMap}
import scala.collection.JavaConverters._
import scala.tools.nsc.io.File

/**
 * This program allows to parse logs generated by Lepton and ADTN plateform.
 * It extracts data from the given files and produces 3 main kind  of information
 *   Global: overview numbers on the experiment such as the duration, number of messages sent/received..
 *   Node: this section contains information on all evolved nodes (activity duration, number of messages sent...) 
 *   Message: give information about messages exchanged during the experiment (source, destination, receive time, ...)
 *
 * Required arguments:
 *      - leptonOutFilePath : the output file produced by Lepton (lepton.out)
 *      - adtnOutDirPath    : the directory containing ADTN output files. 
 *
 * @version 04/2020
 */
object Main {

    def main(args : Array[String]) = {

        if(args.length < 2 || "-h".equals(args(0))) { // usage check 
            println("usage: <lepton_out_file> <adtn_out_dir> [output_file]")
            System.exit(1)
        }

        val leptonOutFilePath = Paths.get(args(0));
        val adtnOutDirPath = Paths.get(args(1));

        var outputFile = "output.txt";
        if(args.length > 2) outputFile = args(2);
        
        println("Starting LogAnalyzer")
        println(" outputFile -> " + outputFile)
        var data = LogAnalyzer.process(leptonOutFilePath, adtnOutDirPath);
        File(outputFile).writeAll(data.toString)
        // println("\n"+data);
        println("LogAnalyzer finished")
    }

    /**
     * This class represents the global information section. It computes the duration of an experiment based on the
     * given starTime and the EndTime of Lepton.
     * 
     *   startTime   : the lepton start time.
     *   endTime     : the lepton end time (date of the last recorded event by lepton)
     *   activeNodes : the number of active nodes
     *   sndEvents   : the total number of messages sent by all nodes during an experiment
     *   rcvEvents   : the total number of messages received by all nodes during an experiment
     */
    case class Global(var startTime : LocalDateTime = LocalDateTime.now, 
        var endTime : LocalDateTime = LocalDateTime.now,
        var activeNodes : Int = 0, var sndEvents : Int = 0, var rcvEvents : Int = 0) {
        val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")

        def duration = ChronoUnit.SECONDS.between(startTime, endTime)

        override def toString() : String = {
            var sb = new StringBuilder
            sb ++= "[Global]" + "\n"
            sb ++= "  start time        : "+ formatter.format(startTime) + "\n"
            sb ++= "  duration (s)      : "+ duration + "\n"
            sb ++= "  active nodes      : "+ activeNodes + "\n"
            sb ++= "  messages sent     : "+ sndEvents +" \n"
            sb ++= "  messages received : "+ rcvEvents + " ("+ Try((rcvEvents*100)/sndEvents).getOrElse(0) +"%)"+ "\n"
            sb ++= "\n"
            sb.toString
        }
    }
    
    /**
     * This class contains information about a Node.
     *
     *   nodeId            : the node identifier.
     *   activityStartTime : date of the first activity of a node (first beacon)
     *   activityEndTime   : date of the last activity of a node
     *   totalSnd          : the total number of messages sent by a node
     *   totalRcv          : the total number of messages sent to a node
     *   nbRcv             : the number of effective messages received by a node.
     *   minNbNeighbors    : the minimum  number of neighbor with which the node interact at a given moment
     *   maxNbNeighbors    : the maximum  number of neighbor with which the node interact at a given moment.
     *   outConnection     : the number connections initiated by a node
     *   inConnection      : the number of connection received by a node.
     */
    case class Node(var nodeId : String, var activityStartTime : Option[LocalDateTime] = None, 
        var activityEndTime : Option[LocalDateTime] = None,
        var totalSnd : Int = 0, var totalRcv : Int = 0, var nbRcv : Int = 0, 
        var minNbNeighbors : Int = 0, var maxNbNeighbors : Int = 0,
        var outConnection : Int = 0, var inConnection : Int = 0
    ) extends Ordered [Node] {

        def activityDuration : Long = ChronoUnit.SECONDS.between(
            activityStartTime.getOrElse(LocalDateTime.now), 
            activityEndTime.getOrElse(LocalDateTime.now)
        )

        override def toString : String = {
            var sb = new StringBuilder
            sb ++= f" ${nodeId}%10s" + " "*6
            sb ++= f" ${activityDuration}%5d" + " "*9
            sb ++= f" ${totalSnd}%3d" + " "*8
            sb ++= f" ${nbRcv}%3d/${totalRcv}" + " "*7
            sb ++= f" ${minNbNeighbors}%2d" + " "*6
            sb ++= f" ${maxNbNeighbors}%2d" + " "*7
            sb ++= f" ${outConnection}%5d" + " "*6
            sb ++= f" ${inConnection}%5d"
            sb.toString
        }

        def compare(that : Node) : Int = this.nodeId compare that.nodeId
    }

    /**
     * This class represents a Message. It contains information on an exchanged message
     * between two nodes.
     *
     *   msgId           : the message identifier
     *   src             : the source nodes of a message.
     *   dst             : the destination node of a message
     *   rcvTime         : the received date of a message
     *   leptonStartTime : the lepton start time. Useful to compute the duration
     */
    case class Message(var msgId : String, var src : String, var dst : String,
        var rcvTime : LocalDateTime, 
        var leptonStartTime : LocalDateTime) extends Ordered[Message] {

        // compute the date when the message has been sent
        // adtn starts its internal timestamp for messages from the year 2000.    
        def sndTime : LocalDateTime = {
            val epoch2000 = 946684800
            val timeStamp = msgId.split("_")(1).toInt
            LocalDateTime.ofInstant(Instant.ofEpochSecond(epoch2000 + timeStamp), ZoneId.systemDefault());
        }    
        def sndStep : Long = ChronoUnit.MILLIS.between(leptonStartTime, sndTime)
        def rcvStep : Long = ChronoUnit.MILLIS.between(leptonStartTime, rcvTime)
        def rcvDuration : Long = ChronoUnit.SECONDS.between(sndTime, rcvTime)
        def compare(that : Message): Int = this.sndTime compareTo that.sndTime

        override def toString : String = {
            var sb = new StringBuilder
            sb ++= f" ${msgId}%20s" + " "*3
            sb ++= f" ${src}%10s" + " "*3
            sb ++= f" ${dst}%10s" + " "*3
            sb ++= f" ${sndStep}%10d" + " "*5
            sb ++= f" ${rcvStep}%10d" + " "*5
            sb ++= f" ${rcvDuration}%10d"
            sb.toString
        }
    }

    /**
     * This class is a container of the 3 main sections of data (Gloabl, Nodes, Massages)
     * extracted from log files.
     */
    case class Data(var global : Global, var nodes : Map[String, Node], var messages : Map[String, Message]) {
        override def toString() = {
            var sb = new StringBuilder
            sb ++= global.toString

            sb ++= "[Nodes]" + "\n"
            sb ++= "-"*95 + "\n"
            sb ++= "    NodeId      duration (s)    sndEvts   nbRcv/total   minNhb   maxNhb     outCon       inCon" + "\n"
            sb ++= "-"*95 + "\n"
            for((k, v) <- nodes) { sb ++= v + "\n" }
            sb ++= "\n"

            sb ++= "[Messages]" + "\n"
            sb ++= "-"*110 + "\n"
            sb ++= " "*8 + "MessageId" + " "*13 + "src" + " "*11 + "dst" + " "*9 + "sndStep" + " "*9 + "rcvStep" + " "*8 + "rcvDuration (s)" + "\n"
            sb ++= "-"*110 + "\n"
            for((k, v) <- messages) { sb ++=  v + "\n" } 
            sb ++= "\n"
            sb.toString;
        }
    }

    /**
     * The main object which analyzes logs
     */
    object LogAnalyzer {
        def process(leptonOutFilePath : Path, adtnOutDirPath : Path) : Data = {

            var nodes = Map[String, Node]()
            var messages = Map[String, Message]()
            var global = Global()
            var data = Data(global, nodes, messages)

            // process lepton out in order to extract useful data
            def processLeptonOut(leptonOutPath : Path) = {
                println("processing Lepton log -> " + leptonOutPath + " ...")
                val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")
                // patterns for extracting useful data
                val pattern_startTime = """\s*start_time\s*: (\d+)""".r; //lepton_
                val pattern_deferred = """\s*start_deferred\s*: (\d+)""".r;
                val pattern_hub = """(\d{4}-\d\d-\d\d \d\d:\d\d:\d\d.\d{3}) hub (.*)""".r;
                val pattern_sdr_rcv = """.*sdr=(\w+),rcv=((?:\w+(?:,\w+)*)?)""".r; // TODO
                val pattern_relay = """relay: opened StreamRelay\((\w+) <=> (\w+)\)""".r;

                Try(Source.fromFile(leptonOutPath.toString())) match { // opening the log file
                    case Success(buff) => { // file correctly opened
                        var startTimeEpoch = 0L;
                        var startDeferred = 0;
                        buff.getLines.foreach( _ match { // reading the file line by line
                            case pattern_startTime(strEpoch) => startTimeEpoch = strEpoch.toLong
                            case pattern_deferred(strDeferred) => startDeferred = strDeferred.toInt
                            case pattern_hub(strDate, infos) => {
                                var date = LocalDateTime.parse(strDate, formatter);
                                data.global.endTime = date
                                infos match {
                                    case pattern_sdr_rcv(nodeId, neighbors) => {
                                        var nbNeighbors = neighbors.split(",").size;
                                        if(data.nodes.contains(nodeId)) {
                                            var node = data.nodes(nodeId)
                                            node.activityEndTime = Some(date)
                                            if(node.minNbNeighbors > nbNeighbors) node.minNbNeighbors = nbNeighbors;
                                            if(node.maxNbNeighbors < nbNeighbors) node.maxNbNeighbors = nbNeighbors;
                                        } else { 
                                            data.nodes += (nodeId -> Node(nodeId, Some(date), Some(date), 0, 0, 0, nbNeighbors, nbNeighbors))
                                        }
                                    }
                                    case pattern_relay(nodeId1, nodeId2) => {
                                        if(data.nodes.contains(nodeId1)) {
                                            var node = data.nodes(nodeId1)
                                            node.activityEndTime = Some(date); 
                                            node.outConnection += 1;
                                        } else {
                                            data.nodes += (nodeId1 -> Node(nodeId1, Some(date), Some(date)))
                                        }
                                        if(data.nodes.contains(nodeId2)) {
                                            var node = data.nodes(nodeId2);
                                            node.activityEndTime = Some(date); 
                                            node.inConnection += 1;
                                        } else {
                                            data.nodes += (nodeId2 -> Node(nodeId2, Some(date), Some(date)))
                                        }
                                    }
                                    case _ =>
                                }
                            }
                            case _ =>
                        })
                        buff.close()
                        data.global.startTime = Instant.ofEpochMilli(startTimeEpoch).atZone(ZoneId.systemDefault()).toLocalDateTime();
                        data.global.startTime.plusSeconds(startDeferred);
                        data.nodes = Map(data.nodes.toSeq.sortWith(_._2 > _._2):_*)
                    }
                    case Failure(e) => println(e) // fail to open the file
                }
                println("job done [Lepton out]")
            }
            
            // process adtn logs in order to extract useful data
            def processNodesLog(adtnOutDirPath_ : Path) = {
                println("processing ADTN Nodes logs -> " + adtnOutDirPath_ + " ...")
                val pattern_main = """\[(\d{4}-\d\d-\d\d \d\d:\d\d:\d\d)\]\[.*\]\[.*\]\[.*\] - (.*)""".r;
                val pattern_create = """New Bundle created (\w+) (\w+)@(\w+)""".r; //dmis01_641397941_0
                val pattern_received = """Received Bundle (\w+) (\w+)@(\w+)""".r;
                // val pattern_forwarding = """Forwarding Message destination? (\w+) (\w+)@(\w+)""".r;
                val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")

                Files.list(adtnOutDirPath_).iterator().asScala // get scala iterator over ADTN log dir path
                    .foreach( nodeDirPath => { // iterate through all files in the directory
                    if(Files.isDirectory(nodeDirPath)) {
                        val logFilePath = nodeDirPath.resolve("adtn.log")
                        if(Files.isRegularFile(logFilePath)) {
                            Try(Source.fromFile(logFilePath.toString())) match {
                                case Success(buff) => {
                                    // val nodeId = nodeDirPath.getFileName.toString
                                    var map = Map[String, Tuple3[LocalDateTime, String, String]]()
                                    buff.getLines.foreach( _ match {
                                        case pattern_main(strDate, infos) => {
                                            val date = LocalDateTime.parse(strDate, formatter);
                                            infos match {
                                                case pattern_create(msgId, src, dst) => { 
                                                    data.global.sndEvents += 1; 
                                                    data.nodes(src).totalSnd +=1; 
                                                    data.nodes(dst).totalRcv +=1; 
                                                }
                                                case pattern_received(msgId, src, dst) => 
                                                    if(!map.contains(msgId)) { map += (msgId -> Tuple3(date, src, dst)) }
                                                // case pattern_forwarding() =>
                                                case _ =>
                                            }
                                        }
                                        case _ =>
                                    })
                                    buff.close
                                    if(!map.isEmpty) { // if at least one message is received
                                        for((msgId, v) <- map) {
                                            val (date, src, dst) = v
                                            data.nodes(dst).nbRcv += 1;
                                            data.global.rcvEvents += 1;
                                            data.messages += (msgId -> Message(msgId, src, dst, date, data.global.startTime))
                                        }
                                    }
                                }
                                case Failure(e) => println(e)
                            }
                        }
                    }
                    data.messages = ListMap(data.messages.toSeq.sortWith(_._2 > _._2):_*) // sorting the map
                })
                println("job done [ADTN nodes]")
            }

            processLeptonOut(leptonOutFilePath)
            processNodesLog(adtnOutDirPath)
            data.global.activeNodes = data.nodes.size
            data
        }
    }

}